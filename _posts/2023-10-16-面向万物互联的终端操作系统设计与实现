---
layout: post
title: 面向万物互联的终端操作系统设计与实现
cover-img: /assets/img/微信图片_20230505141052.jpg
thumbnail-img: /assets/img/微信图片_20230505143227.jpg
share-img: /assets/img/微信图片_20230505141157.jpg
tags: [report, os]
---

# 1. 引言
## 1.1 万物互联时代
万物互联定义为将人、流程、数据和事物结合一起，使得网络连接更具相关性和价值，即使所有设备都通过网络互联。随着5G时代到来，数据传输速率成倍加快、可访问的终端数量显著增加、连接质量更可靠、延迟更低，显然，我们正大步进入万物互联时代：从灯泡到汽车，各种设备都在经历智能化过程，人工智能的出现也对计算能力提出了更高的要求，云计算使得海量数据计算不再局限于单个终端。理论上，它正在趋于无穷。因此，新时代、新技术对新一代操作系统的需求也迫在眉睫。
## 1.2 微内核操作系统
新时代需要什么样的操作系统？

1. 可扩展性：需要隐藏不同硬件的细节，所以需要考虑对不同硬件的支持；除内核之外，其他功能应该作为附属组件存在。
2. 可移植性：将底层硬件和应用程序隔离，可移植到不同硬件平台。
3. 安全性与可靠性：能够防止恶意攻击;对其应用程序应该有一种身份验证模式，以确保在长期远程工作期间不会出现故障。
4. 连接性：保持网络系统下各设备的连接。

目前操作系统内核主要有两种形态，宏内核(Monolithic kernel)与微内核(Micro Kernel)。宏内核的特点为大量功能集中在内核态实现,内核处于特权级。这就导致了安全性和可靠性的缺乏，因为模块之间没有很强的隔离;由于缺乏实时性支持和系统的复杂性，无法进行最坏情况下的延迟分析;而且，系统的庞大规模阻碍了创新，例如Linux就有超过2000万行代码。

而微内核的基本思想是简化内核功能，只提供最基础的服务[ [1] 《股市动态分析》研究部，华为鸿蒙系统:引领万物互联突破科技封锁[J]，股市动态分析，pp. 2021(12):6-11.]（比如进程间通信、时钟任务），将尽可能多的功能移出内核态至用户态（例如文件系统、进程管理、设备驱动）。由于其模块大多与底层硬件无关，易于扩展和移植，能够灵活适应各种硬件设备；同时，各模块之间通过进程间通信相互连接，可以很好地支持分布式系统和网络系统；服务间进程粒度隔离，实现了操作系统容错的模块化，提高了操作系统的安全性和可靠性。

因此，相较之下，微内核OS是面向万物互联的终端操作系统的发展方向，而本论文的目的则正是基于微内核原理设计一种支持上述万物互联的新型操作系统。

# 2. 整体设计
## 2.1 系统架构
微内核架构`(Microkernel Architecture)`有时也被称为插件架构模式`（plug-in architecture pattern）`，其包含两部分组件：核心系统`（core system）`和插件模块`（plug-in modules）`，即内核和其他功能服务。故我们要设计一个微内核系统，需要了解内核需要完成什么任务以及需要增加什么插件。

参考`MINIX3`的系统设计，内核需要完成对各插件的管理、插件间的通信以及插件与核心系统的连接，用户态必要包含的服务有进程管理、文件系统、内存管理器和设备驱动器。该架构模式实现了各插件之间的功能隔离，且具有很好的可扩展性，可以通过插件向核心应用添加额外的功能，因此除此之外，我们依然可以根据需要灵活地添加服务插件。初步设想的操作系统架构如图1所示：


图 1 系统架构
### 2.1.1 内核组成
如图1所示，内核处在该系统架构的最核心位置，其主要组成有:

(1)插件管理，管理各插件的调度和状态转换。为了实现某特定功能，内核需要加载并运行某些插件。故内核需要维护当前可用插件、如何加载、何时加载等信息。我们参考Windows中的注册表机制：在内核中维护一个插件注册表，这个注册表存储所有注册在内核中插件模块的信息，包括内存位置、名字、加载时间与生命周期等。这样，内核会知道服务进程（Server Process）的内存位置，并从内存中加载并运行这些程序。同时，因为插件位于用户空间，这种内核与用户空间的隔离性确保了某插件程序中存在的错误仅存在于其所在线程，一旦出错，不会影响内核运行甚至导致崩溃。当内核发送给服务进程的信息未被接受时，内核会重新启动插件。

(2)插件间通信，处理插件间的通信。由于插件之间并无直接联系，通信必须通过内核完成，故其需要提供一个通信机制，我们采用MINIX3的`IPC通信机制 `。例如，[ [2] Andrew S. Tanenbaum, Albert S.Woodhull, 操作系统设计与实现(中文版)，2007, pp. 121]用户需要创建新进程，于是向进程管理器发送请求服务的消息，此时需要调用内核的消息处理功能。内核检查消息接收端是否有效，然后分配发送缓冲区和接收缓冲区，将数据从发送端复制到接收端。其中IPC的实现如图2所示：

图 2 IPC通信机制
(3)插件的连接，指示插件如何连接到核心系统。为了便于新的插件加入并与内核关联，我们需要规范插件与内核的连接模式，之后保证插件按规则实现，内核按规则加载即可。常用的连接模式是消息模式，但针对万物互联的前提，为了实现多终端之间的互通，我们可以使用分布式的协议，采用HTTP协议的形式，通过蓝牙，维护一个局域网，让这些设备可以互相发送HTTP报文，这样我们可以把其它设备当做插件连接到内核中来。

除此之外，内核空间即内核的地址空间中还存在两个独立的进程，且有着各自的调用栈：

(4)时钟任务，与产生时钟信号的硬件进行交互，服务于内核的进程调度功能。时钟任务模块只与内核工作，用户的应用程序无法访问时钟任务模块。

(5)系统任务，为处于用户空间的设备驱动器等提供内核调用接口。例如,设备驱动需要访问I/O端口，但其位于用户空间，无法直接执行访问I/O端口的指令，因此需要向系统任务模块发出请求。在接收到请求消息后，系统任务模块与内核进行交互，内核最终为它们执行指令。
### 2.1.2 主要插件
如图1所示，其他插件模块处在该系统架构的用户空间运行，作为一个个独立的进程被内核所调度，其主要组成有:

1. 进程管理模块。管理控制进程的生命周期，实现进程的创建、阻塞、卸载、内存空间分配以及资源分配等功能。
2. 文件系统模块。负责文件信息的管理和访问，统一管理用户和系统信息的存储、检索、更新、共享和保护，为用户提供一套方便有效的文件的使用与操作方法。
3. 内存管理模块。实现管理内存资源、分配和回收内存、保护内存、内存扩充等功能。
4. 设备驱动模块。向内核发出一个请求消息来读写I/O端口, 通过内核调用可以将设备读取的数据复制到另一个进程的地址空间中。
5. 根据功能需要灵活地添加其他插件。
### 2.1.3 工作流程
该系统架构初步的组成与功能就如上所述，其具体的工作流程如图3：

图 3 工作流程
1. 用户进程为实现某一服务，如执行系统调用，则通过trampoline引发中断，并向内核空间发送消息。
2. 内核通过轮询注册表，找到管理此用户进程或提供服务的插件位置，即服务进程。
3. 内核将消息发送给对应插件，即此服务进程，交由服务进程处理。
4. 服务进程处理任务。
5. 处理完毕后，返回内核。
6. 内核接收到返回信息后，恢复中断前的状态并将控制权交还给用户进程。
## 2.2 功能扩展
操作系统架构初步完成后，为了满足其他服务需要，应当可以根据需要进行功能扩展。此处以新加入一个硬件设备如摄像头或传感器为例。

要向操作系统中添加硬件设备，可参考MINIX3连接外部I/O设备的做法，实现用户级空间的一个完整的I/O系统调用。首先，我们维护一个dev文件夹来存储连接到新增设备的硬件，同时，我们通过设备驱动器来管理硬件，通过向其中注册设备名与参数，将设备连接到本机；[ [3] 吴帆，基于微内核的设备驱动框架研究[D]，浙江大学，2010.]I/0模块封装端口I/0和内存映射的I/0，然后硬件执行I/O操作，内存管理模块将系统中空闲的物理内存映射到其所在地址空间，并加以统一的维护和管理；中断程序则在微内核基础上进一步封装中断处理机制作，实现用户对中断的处理和响应，并在I/O操作结束时唤醒驱动程序。

除此之外，由于本系统架构面向万物互联，除硬件外连驱动，我们可以参考蓝牙连接，通过设备驱动器来向需要连接的设备发送本架构中插件连接所采用的HTTP协议报文，接收报文后，向内核发送请求，若内核检查接口与内存后同意接受连接，之后按照规范的连接格式，将此设备视为一个新的插件插入到内核中，将其视为一个服务进程即可。

由此，我们可以实现操作系统对于功能的扩展以适应多功能的需要。
## 2.3 系统调用
操作系统的框架搭建至此告一段落，系统调用作为操作系统与应用程序之间的接口，接下来将被着重讨论。由于本操作系统灵感主要基于微内核MINIX3代码，我们参照其系统调用实现思想进行叙述。

[ [4] 岳婧媛,李华,郭亚杰,贺楠,庞滨，基于属性的Minix3系统调用的建模和测试[J]，内蒙古大学学报(自然科学版)，2011，pp. 42(05):570-575.
  [5] Andrew S. Tanenbaum, Albert S.Woodhull, 操作系统设计与实现(中文版)，2007, pp. 32]以常见的fork系统调用即创建一个子进程为例：用户进程发出fork调用指令即调用_syscall()发送消息，最终转化为对内核中sys_call()的调用，该处对应的内核函数代码获取消息并通过其address地址参数得知具体内容，并查询系统调用表检查此次系统调用的编号，并将其在适当的时候传输到相应的处理程序。本例中内存管理器负责fork的工作，其不断获取和处理传输而来的消息，并将其存储在全局变量m_in中。之后，其获取m_in的内容以知晓要执行的是fork操作，将其分派到相应的处理函数do_fork()完成所需操作。执行完成后，执行函数返回指令，返回用户程序。系统调用的整个过程就此完成。但是当今主流的操作系统以宏内核架构为主，若是支持的嵌入式设备为宏内核，其调用则缺少了消息传递机制，上述设想难以直接实现，因此我们需要增加一个中转站，以跳转到微内核的系统调用。以宏内核fork调用为例，在连接到一个设备时，通过驱动器的某一位来判定此设备是否为宏内核设备，判定成功时，系统将会把一份映射表链接进入此设备的运行代码中，当此进程调用fork时，会根据此映射表进行查询，并调用本机微内核系统中的fork系统调用，如此，我们便完成了与宏内核系统调用的兼容。

在本文的系统中进行系统调用的情况如图4所示（以fork为例）：

图 4 fork系统调用
其他系统调用的情况与此类似：通过调用_syscall()发送消息，并通过相应的进程取出消息、进行处理。
此外，若要新增系统调用，可以仿照Minix3的project中新增系统调用chrt的实现方法，在系统任务中实现系统调用的核心函数。通过消息机制，接口函数首先将消息发送给内核层；内核层接收到信息后，根据映射信息，将此消息发送给服务进程中处理此函数的进程；随后服务进程将消息发送给核心的执行函数；最后，当核心函数执行完毕后，消息沿着相反的路径返回到接口函数。
2.4 系统服务管理
我们为用户程序提供了操作系统关于各服务的接口即系统调用，但各执行系统指定功能的程序、进程即系统服务（system services）则也需要统一的调度管理，以及时正确的相应用户调用。系统服务，也可以称之为守护进程，这是一种运行在后台的特殊进程，它独立于控制终端并且周期性地执行某种任务或循环等待处理某些事件的发生。对于微内核OS而言，用户进程的驱动、文件系统等等都是由其守护进程去完成的，换而言之，守护线程也就是前文中所说的插件，即服务进程。
那么如何对这些插件进行管理？在上文中我们提出了在内核中使用注册表机制对插件进行统一管理。
1.	注册表的数据结构
注册表事实上就是一种数据库，这里倾向于使用红黑树来实现“键-值”的映射，其中，“键”为此插件唯一标识的名称（或ID），“值”为此插件可执行文件的内存位置。红黑树的排序方法可定义为键值的字典序大小。
2.	插件的运行与终止
由于内核管理着注册表，当我们需要运行某个插件时，首先，我们会向内核发出请求，通过IPC机制，发送一条包涵插件ID、可执行文件位置、插件生命周期的消息。当内核接收消息后，会向注册表中插入此插件的信息，并新建进程，将进程生命周期设置为消息传递的生命周期，最后，将此进程在放在后台运行。而当我们需要终止某个插件时，我们只需要将生命周期设置为0，那么内核就能够将此进程结束，并删除注册表中对应的条目。
3.	注册表的轮询
当进行系统调用时，由图3可知，我们需要对注册表进行轮询，以找到对应的服务进程。因此，我们需要一个映射表，将对应的特定消息映射为其对应服务进程的ID，并通过遍历红黑树，找到服务进程的地址，并将消息传递给服务进程以获取相对应的服务。

于是，通过注册表机制，我们就可以在保留了微内核的特性的基础上，也对插件进行了良好的管理，以便支持其他程序。

# 3. 进程管理
## 3.1 进程控制块
我们阐述了本操作系统的调用接口以及对各种服务的管理，接下来自然要谈一谈它们的底层实现。操作系统各服务都是通过进程实现的，进程是抽象出的用于运行的程序，是资源配置的基本单位，我们要实现某些功能，自然就需要运行相对应的进程。为了描述控制进程的运行，我们需要在系统的数据结构中存储进程的管理和控制信息，即进程控制块(Process Control Block)。每个进程都有一个进程控制块，它在进程创建时创建，并伴随整个进程，直到进程撤消而删除。

基于微内核的原理之上，又为了本操作系统将来能更好地适应兼容宏内核的设备，我们参考了xv6与MINIX3中进程控制块的结构，又根据本系统的需求进行相应的增添与简化，最终我们的控制块代码简易设计如下：
```c
1.enum procstate { UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
2.
3.// Per-process state
4.struct proc {
5.  struct spinlock lock;         //Used of busy waiting
6.
7.  // p->lock must be held when using these:
8.  enum procstate state;        // Process state
9.  int killed;                  // If non-zero, have been killed
10.  int xstate;                  // Exit status to be returned to parent's wait
11.  int pid;                     // Process ID
12.
13.  // wait_lock must be held when using this:
14.  struct proc *parent;         // Parent process
15.
16.  // these are private to the process, so p->lock need not be held.
17.  uint64 kstack;               // Virtual address of kernel stack
18.  uint64 sz;                   // Size of process memory (bytes)
19.  pagetable_t pagetable;       // User page table
20.  struct trapframe *trapframe; // data page for trampoline.S
21.  struct context context;      // swtch() here to run process
22.  struct file *ofile[NOFILE];  // Open files
23.  char name[16];               // Process name (debugging)
24.    
25.  char priority;  /* current process priority */
26.  struct proc *p_nextready; /* pointer to next ready process */
27.  int flag; /* process is a resampling machine */
28.};
```
首先我们定义进程的几种状态，包括运行、僵死、休眠等等，然后进一步定义进程控制块的具体内容：
> 1. lock：定义自旋锁，用于避免忙等待
> 2. state：表明进程的状态，有创建态，终止态，阻塞态，就绪态，运行态，僵死态这几种状态
> 3. killed：用以标记此进程是否被系统调用kill终止，如果非0，则该进程已被杀死
> 4. xstate：进程退出的所返回的代码（可用来debug）
> 5. pid：进程唯一标识的id
> 6. parent：标识父进程
> 7. kstack：内核栈的虚拟地址
> 8. sz：此进程的占据内存空间的大小
> 9. pagetable：进程的页表
> 10. trapframe：陷阱帧，用于保存线程的执行状态，为跳床页的地址，我们可以通过跳床页来引发中断
> 11. context：进程上下文（用于上下文切换）
> 12. name：进程的名字（可用于debug）
> 13. priority：进程优先级，用于进程调度来决定进程运行顺序
> 14. nextready：进程链表中下一个准备好的进程
以上为进程控制块的基本内容，但为充分考虑后续关于重采样的调度算法，我们还需在控制块中中加入成员：
> 15.flag：标识该进程是否为重采样进程
至此，进程控制块的设计告一段落，操作系统基础的架构设计也就如上所述。接下来，就可以根据我们的需求来增添相应的功能设备。
## 3.2 核酸采样功能
近年来新冠疫情肆虐，核酸检测成了我们生活中的常见风景。本操作系统旨在契合时代发展，故在完成上述基础内容之外，想要进一步细化，设计一个全自动核酸采样设备，以减轻工作人员的负担，更好地保障公民健康。

现设想这套终端设备外设包括m个采样机械臂和n个识别扫码仪，设可容纳人员识别扫码后等待采样的人数为k，即采样等待区为k人。根据所学生产者消费者知识模型化表述如下：将识别扫码仪视为生产者、采样机械臂视为消费者，前者识别人员进入等待区，后者使人员得到采样并离开等待区，则我们[ [6] 李晓宇，操作系统中并发进程的生产者—消费者问题的研究[J]，许昌学院学报，2013，pp. 32(02):52-56.]有n个生产者和m个消费者，共享一个k个单位的缓冲区，当缓冲区未满时，生产者进程pi所生产的产品可以放入缓冲区；当缓冲区非空时，消费者进程cj就可以从缓冲区取走并消耗产品。但是生产者与消费者模型中，各生产者之间、各消费者之间都是互斥的，当某生产/消费者进行操作时，其他生产/消费者会被阻塞。但此问题中我们可知pi和cj为并发进程，所以结合另一经典模型读者写者问题，我们允许多个进程同时读写，并且设计读写公平的算法。同时，保证读写进程之间的互斥，我们可以添加信号量来实现。在操作系统中，信号量在解决各种进程同步问题方面扮演者至关重要的角色，因为其本质上代表着某种资源的可用数量。

故基于我们最终的模型糅合以及信号量的思想，最终的机械臂即消费者、识别仪即生产者的伪代码设计各如下所示：
```c
Algorithm 1: Consumer with Reader Version
Data: 维护生产者消费者间竞争公平的信号量rwmutex，维护生产者消费者间互斥的信号量wmutex，消费者进程个数readcount，维护更新readcount的信号量readmutex，消费的产品item，生产者生产的产品个数count，维护生产者之间的信号量mutex，缓冲区数组buffer[]
1 while True do
2    wait(rwmutex)
3    wait(readmutex)
4    If readcount == 0 then
5       wait(wmutex)
6    end
7    readcount ← readcount + 1
8    signal(readmutex)
9    signal(rwmutex)
10    item ← remove_item(buffer)
11    If count ≤ k and mutex is wait then
12       signal(mutex)
13    end
14    wait(readmutex)
15    readcount ← readcount - 1
16    If readcount == 0 then
17       signal(wmutex)
18    end
19    signal(readmutex)
20    consumerOp(item)
21 end
```
```c
Algorithm 2: Producer with Reader Version
Data: 维护生产者消费者间竞争公平的信号量rwmutex，维护生产者消费者间互斥的信号量wmutex，生产者进程个数writecount，维护更新writecount的信号量writemutex，生产的产品item，生产者生产的产品个数count，维护生产者之间的信号量mutex，缓冲区数组buffer[]
1 while True do
2    wait(rwmutex)
3    wait(mutex)
4    If writecount == 0 then
5       wait(wmutex)
6    end
7    writecount ← writecount + 1
8    signal(writemutex)
9    put(buffer, item)
10    count ← count + 1
11    If count > k then
12       wait(writemutex)
13       signal(wmutex)
14    else
15       wait(writemutex)
16       writecount ← writecount - 1
17       If writecount == 0 then
18          signal(wmutex)
19       end
20       signal(writemutex)
21    end
22    signal(rwmutex)
23 end
```
我们定义一个信号量`rwmuter`，用于维护生产者与消费者公平生产消费，即按照生产者消费者排队进入的先后顺序进行操作，避免生产者一直生产而消费者一直阻塞等问题；同时，我们维护一个临界区的信号量`wmutex`，用于在生产/消费者工作时阻塞另一方访问；我们用`readcount`记录消费者进程的个数，并用`readmutex`控制对其的修改,用`writecount`记录生产者进程的个数，并用`writemutex`控制对其的修改；用`count`记录生产者生产的产品个数，并用`mutex`维护生产者之间的互斥；并且我们维护一个大小为`k`的缓冲区数组`buffer`，用于控制缓冲区大小。

对于消费者，当某一进程进入循环后，阻塞其他所有正在等待的进程，阻塞其他进程对进程个数的修改，如果此时消费者进程数为0即第一个进程到来，则阻塞所有的生产者进程，对消费者进程数自增一，恢复修改进程个数，撤销对等待进程的阻塞，允许并发运行；消费者进程从缓冲区数组中取出要消费的产品后，还需要对生产者产品数量count进行判断，若当前的操作能使`count`小于等于`k`并且生产者之间的锁`mutex`仍处于阻塞状态，那么我们可以解开生产者之间的阻塞，使得生产者能够继续生产。在这些操作结束后，重新阻塞对进程数的修改，进程个数自减一，即结束当前进程；如果进程个数为0即为最后一个进程结束，则恢复对临界区的阻塞，恢复对生产者的阻塞。之后进行消费操作即机械臂采样。

而对于生产者进程，由于这里的生产者之间是不互斥的，所以我们需要借鉴消费者中的方法，维护一个生产者进程数量的writecount，在遇到第一个生产者进程时为`wmutex`加锁，阻塞消费者，而在最后一个生产者进程结束时，解除对消费者的阻塞。但对于生产者而言，我们还需要注意生产的产品数量不能超过缓冲区的大小k，于是我们需要维护一个产品数量`count`与一个生产者之间的信号量`mutex`，对于每个生产者进程，我们需要去检查当前生产的数量是否超过了缓冲区大小，若超过，则阻塞所有生产者，并解除对消费者的阻塞；否则，生产者照常并发进行。

至此，我们的自动核酸采样终端设备的设计基本完成，但还需要分析考虑这一套系统对等待人员的处理能力，以便在等待区人员到达上限后及时广播该采样点等候人员过多的提示音，避免过度拥挤以及妥善排队人员过长等待的心情。
## 3.3 处理能力分析
首先，我们假设此核酸检测点开放时间为8小时（每日九点开放到十七点），人员到达速率为`α`，一个识别仪识别一个二维码的时间为`t0`，一个采样臂采样的时间为t1（假设采样臂不会重采样）。

针对上述同步算法，我们做出如下分析：

设定人员分布时间服从均匀分布，即 `time～U(9, 17)`。显然，识别仪往缓冲区送入的人数为：
				（1）
而机械臂从缓冲区取走的人数为：

	（2）	显然，当α较小时，我们无须担心识别仪的处理能力，此系统不论CPU使用率还是内存使用率都处于较为空闲的状态，处理速度较快。
 
	当α增大后，可分为两种情况讨论：
 
	1. `(n﹤α)∧(n≤t0×m)`
	此时，识别仪的进程数会达到最大，但采样机械臂的进程数不会，这时，由于α的增加，识别仪进程会不断的被阻塞，但阻塞也会很快的被机械臂进程解开。于是这种情况下，我们不需要当识别仪被阻塞时便发出提示音，我们可以加入一个修正项γ，当满足
       		（3）
时，广播出人员过多的提示音。这样可以避免提示音的无效广播，对系统性能也有一定的提升。

或者，我们也可以使用懒提示的方法，我们引入一个时间跨度称为Δ来表示允许缓冲区达到临界状态的最长时间，若满足

 						（4）
那么我们可以认为，阻塞不能在极短时间内解除，这时候便可以做出等待区域人数过多的判断，也就可以发出人数过多的广播了。

2. `(n﹤α)∧(n﹥t0×m)`

与上面情况不同的是，在这种情况中，机械臂进程数也会达到最大数目，由于机械臂与识别仪之间是公平竞争关系而非某一种进程优先，当识别仪被阻塞时，若依照上面的方法，我们只能期待于机械臂能够更快速的运行，使得等待区域内人数少于k，但由于假设条件我们知道，机械臂的数量并不支持快速消除这种溢出，那么这时候识别仪之间的的阻塞信号不会被轻易解开，并且如果输入仍在继续的话，识别仪进程的输入缓冲区会堆积而溢出，导致内存泄漏等等一系列严重的问题，于是在这里，我们通过限制条件来解决这一情况：
 			（5）

注意到，这里使用了“≥”而非“＞”，这是因为我们需要尽可能避免这种情况的出现，那么当缓冲区刚满时就需要发出广播以免后续长时间阻塞的出现。

若人员速率服从的是泊松分布，则上述的α非固定值，而要依照其概率公式计算得出：，后续的分析则一致。
## 3.4 重采样调度
在上述过程中，我们已对该采样系统的处理能力有了一定了解、并作出了相应的应对，但此采样设备在实际运用中还会遇到一些问题，譬如应用的绝对误差等。我们考虑采样机械臂的情况，定义每个采样机械臂由系统的一个进程控制，每次操作过程包括人脸部定位和采样操作，但人脸定位识别有一定误差，如果定位不准确，我们则需要使被采样者保持继续不动并进行重新定位识别。若是这些采样者同其他采样者的识别优先级一样，可能会发生被采样者需过长时间保持不动的情况，不利于等待人员的愉悦度以及设备的运行。因此我们需要提高重采样时机械臂的进程优先级，于是需要设计对应的调度算法。

我们可以参考Minix3的`project chrt`中进程调度的实现方法，修改判断进程优先级的判定法则。考虑先前我们对进程控制块的设计，根据flag标识判定某一进程是否为重采样，定义重采样的用户进程相对于其它用户进程具有更高的优先级，从而被优先调度运行。

设计的调度器算法如下：
```c
Algorithm 3: Process Scheduling
Result: 当前优先级最高的进程result
1 i ← 0
2 for i ≤ MAX_P do
3    proc ← proc_queue[i]    //  proc 为链表的表头
4    If proc ≠ NULL then
5       while traverse(proc) is True do   // 遍历列表
6          temp ← traverse(proc)
7          If temp.flag == 1 then
8             result ← temp
9          end
10       end
11       pick(result)   // 选择此进程返回
12    end
13 end
```
仿照minix进程调度的思想，[ [7] Andrew S. Tanenbaum, Albert S.Woodhull, 操作系统设计与实现(中文版)，2007, pp. 124-126]我们让调度器维护一系列MAX_P个可运行的进程队列，每个队列都具有一个优先级，但并不一定在任一时刻所有的队列都在使用，队列0具有最高的优先级。队列内部采用时间片轮转调度算法（RR），即如果某处于运行态的进程用完了它的时间片，则被移到队尾且被分配一个新的时间片。我们运行一个调度算法来维护优先级队列：首先找到最高的非空的优先级队列，选取队首的进程运行，注意应将处于就绪态的重采样进程置于对应优先级队列首部；另外，进程IDLE保持在最低优先级队列就绪，当所有高于其的优先级队列都为空时，该进程才运行。最后，我们需引用函数指示对一个进程位于哪个队列、置于队首或队尾以及将某一运行态进程转换为非就绪态。

对于进程队列而言，每个队列事实上都是一个链表，进程间通过`nextready`串联起来。在调度器中，我们通过遍历准备就绪的进程，并判断当前进程的flag是否为1，也就是是否为重采样机器，若满足此条件，则我们可以调用pick函数将此进程选出并设置为优先级最高。但注意，每次选择完后，我们需要对进程的flag进行维护，防止某一个重采样进程被反复认定为重采样。如果用户进程意识到发生重采样，譬如其维护一个timeout判断机械臂识别是否超时，若超时则判断为重采样等，可以进行系统调用，更改进程的flag使其为1，这样我们授予用户进程更多的权限，对于重采样的识别，用户进程的敏感度会更高；且不需要让内核一直监听进程的工作时间以判断是否发生重采样，减轻内核工作负担。

至此，我们规范了本系统的调度算法，减免因故重采样的人员长久等待的情形出现。
# 4. 内存管理
## 4.1 页面置换算法
我们已经解决了该自动核酸采样中的关键问题，但一个完整的系统中运行的进程除了采样机械臂和扫码仪，还需要后台运行的监控进程来负责统计及上传已测核酸人数以及语音广播进程来不定期广播提示信息等等。而存储器是一种重要的资源，我们必须仔细管理，为了合理利用内存，我们需要仔细讨论进程的换进换出以及页面置换，使其满足我们的性能要求。

当用户程序需要在内存和磁盘中换进换出时，不是以整个程序为单位，而是以页面为单位。程序运行过程中，如果被访问的页面不在内存中，就会引发缺页中断，然后操作系统将所需页面从磁盘写入内存。若内存中有空闲页面，则可将其直接装入某空闲页面中；若无，则需先选择一个物理页面写回磁盘以腾出一个空闲页面，才能将所需页面写入。但如何挑选上述物理页面需要一定的算法支持，即页面置换算法。若算法不恰当，可能会导致刚被换出的页面短时间内被再次访问，则需将其调入而将另一页置换出去，另一页不久又被访问,则需再次置换，即产生了抖动现象。这种情况下，系统花费大量开销进行页面的换进换出，实际效率低下，因此我们说页面置换算法的好坏能直接影响系统性能的优劣。

而且，根据访问的局部性原理，在进程运行的任一阶段，它只会去访问一小部分的页面，我们将最近k次内存访问所访问过的页面集合称为它的工作集。因此，在每个一定时间段内，应该将工作集保存在内存中。因此，当一个进程刚开始运行时，可以先根据进程的大小给它分配一定数量的物理页面，然后在运行过程中动态地调整它的内存空间的大小。

结合页式存储管理和工作集模型，我们知道最近最久未使用算法（LRU）是最接近最优页面置换的算法，但受限于硬件要求难以实现，在软件契合的基础上，我们可以参考老化算法，[ [8] Andrew S. Tanenbaum, Albert S.Woodhull, 操作系统设计与实现(中文版)，2007, pp. 274、277]设置一个一定位的软件计数器，初值为0，在每一个时钟节拍后，操作系统对内存中所有页面进行扫描，用R位定义是否被访问，为1即被访问，每次扫描后先将计数器的值右移一位，然后将R位的值加到最左端。当一个缺页中断发生时，计数器值最小的那个页面将被淘汰。但为了实现工作集模型，我们需要还追踪哪些页面属于工作集，以便当发生页面置换时，优先从非工作集的页面置换。对于任何一个页面，如果在它的计数值的高n位中包含有一个1，那么将这个页面视为工作集中的一个成员。如果一个页面连续n个时钟周期未被访问，就可以将它从工作集中删除。因此，工作集页面标志位在左端，同时表示最近一段时钟节拍内已被访问，那么最近最少访问的且不在工作集中的页面无疑还是计数器值最小的，与原置换算法的判断标准一致，同时，这种思想也与LRU的最近最久未使用一致，有利于利用访问的局部性原理以降低缺页率和抖动现象。

另外，若工作集页面过多无疑会造成内存负担，过少则会导致访问命中下降，因此我们需要控制分配集的大小，这可以通过缺页率算法（PFF）来实现。[ [9] Andrew S. Tanenbaum, Albert S.Woodhull, 操作系统设计与实现(中文版)，2007, pp. 278-279]定义缺页率为在一秒钟内出现的缺页次数或过去几秒钟内缺页率的一个平均值。对于缺页率我们设置两个界线：下界B和上界A。若某个进程的缺页率过高、超出上界A，则可能发生抖动，则应给该进程分配更多物理页面以降低缺页率；若缺页率太低、低于下界B，则说明该进程分配的物理页面过多，可以适当删去一些以减少内存空间的占用。该算法旨在控制每个进程的缺页率，使其维持一个合理的范围，以降低进程的缺页率的同时也不必对内存空间造成太大负担。

这样，我们一方面规划了所需的各进程在内存外存中存储调入的行为方针，一方面也保证了缺页命中等问题不至于频发，提高了系统性能。
# 5. 文件系统
## 5.1 类UNIX文件系统优化
除了内存管理之外，所有的计算机应用程序都需要存储和检索信息。一个进程运行时，可以将一些信息保存在自己的地址空间中，但这种存储能力局限于虚拟地址空间的大小，对一些应用程序大小可能足够，但对于其他应用而言则可能不够。譬如我们使用本操作系统的自动核酸采样设备，可以获取到包括人员姓名、身份证号码、试管编号、采样时间、采样点代码等的采样信息，我们需要能存储这些大量信息，并且在某个使用这些信息的进程终止时，其能够得以保存，并保证多个进程可以并发地访问这些信息。因此我们可以将信息以文件(file)为单位存储在磁盘或其他外部介质上，这样进程可以读取文件，也可以在需要的时候创建新文件。存储在文件中的信息是永久性的，不会受到进程的创建和终止的影响，只有当用户明确地要删除时，文件才会消失。因此，我们需要仔细设计我们的文件系统(file system)以处理与文件有关的各种事情，对此，我们可以类比UNIX文件系统，针对我们的结构化采样数据信息进一步地优化，以优化存储空间管理和外存数据读写的性能。

文件系统通常保存在磁盘上，我们的文件系统可对于磁盘分区的布局如下所示：

图 5 磁盘分区布局
[ [10] Andrew S. Tanenbaum, Albert S.Woodhull, 操作系统设计与实现(中文版)，2007, pp. 343]除预留一个引导块以供包含一个可引导的操作系统外，我们有超级块(superblock)，它包含关于文件系统的所有关键参数，当计算机被启动或文件系统被首次接触时，这些内容会被装入内存。然后是空闲空间管理，主要包括文件系统中空闲物理块的管理信息。随后是索引节点，即一组数据结构，与文件一一对应，描述该文件所有的属性信息以及在磁盘上的存储位置。再后面是根目录，即文件系统树的根节点。在剩余的磁盘空间中存放所有其他的目录和文件。

然后，在物理结构上实现文件的存储，即文件块到物理块间的映射，我们可以使用索引节点的方法来实现，其优点为：当某文件被打开时，才需将它对应的i节点写入内存。若一个i节点需占据n字节，且最多能同时打开k个文件，则我们所需用于文件i节点的内存空间不超过kn字节，那么系统仅需提前预留kn字节的内存空间即可。

同时，参考unix文件系统，为了更好的利用磁盘空间，我们可以允许文件在磁盘上不连续存放，同时综合使用多级间接块来寻址，在索引节点中建立13个地址项，如图6所示：

图 6 索引地址结构

这种索引结构可以实现对不同大小的文件分类处理，据unix统计，80%的文件都为小型文件，其他为大型文件，这其中仅1%为超大型文件。对于长度不超过10个物理块的小型文件，我们可以在i节点中包括该文件所在的磁盘块地址；对中、大型文件则使用一级或两级间接块来寻址；另外，对于超大型文件，我们使用三级间接块寻址。索引节点占用空间小，这样的设计下，不仅可以实现对小文件的快速索引，也分担了大型、超大型文件的压力。

另外，针对我们采样信息的结构化数据模式，也可以在文件的存储上设计相应的优化方式，一为文件体积的优化，二为磁盘空间管理的优化。

对于收集到的采样信息，我们可以很轻易地构造出一种结构来存储：
```c
1.struct Node {
2.  struct Person{
3.    char name[20];
4.    char id_num[30];
5.  }
6.  uint64 id;
7.  time_t time;
8.  int place_id;
9.}
但是，这样一个Node所占用内存的大小为 24 字节。但事实上，在struct Person 中，我们已经开辟了很多空间，这些空间在结构体模式下可能会有很多空余，因此，我们可以将Node声明为一个联合而非结构体：
1.union Node {
2.  struct Person{
3.    char name[20];
4.    char id_num[30];
5.    uint64 id;
6.  }
7.  time_t time;
8.  int place_id;
9.}
```
这样，一个Node仅占用 8 个字节，优化到了原来的三分之一。如果我们的数据通过这样的方式存储进来，那么一份文件占用的内存就会大大减小，相同的储存空间就能够存储更多的文件。但仅仅是这样还不够，由于文件系统是把文件分割成固定大小的块来存储，各块之间不一定相邻，所以，在缩小文件体积的基础上，我们还需要其他的方法来优化存储空间。

对于磁盘空间的管理，由于当前的磁盘体积达到1T以上已经成为常态，因此我们可以把一个块设计为 64 KB，这样能在空间利用率与读写性能上达到平衡。

而对于空闲块的管理，首先，我们可以使用位图来管理空闲空间。我们通过某一位的0/1标识，来确定这一块磁盘区域是否被分配。通过位图，我们可以极大的缩小管理空闲区域所占用的内存，因为每一块内存空间的状态只需要一位就可以描述了。当磁盘空闲块较多时，通过位图，我们随机选取一些空闲块，作为链表的表头，并在此基础上使用链表法，这样可以节省查询的时间，并且这些链表也并不会占用太多的内存。这样结合的方法，不像单纯链表法一样占用内存大，并且当寻找一块空闲块时也不需要遍历位图而导致花费太多时间。

外存读写文件的性能也是文件系统需要考虑的问题之一。我们可以使用块高速缓存来提高I/O性能，[ [11] Andrew S. Tanenbaum, Albert S.Woodhull, 操作系统设计与实现(中文版)，2007, pp. 386]设立一个固定长度的缓冲区数组，每个缓冲区由包含指针、计数器和标志位的头和包含一个磁盘块大小的空间的体组成，并且所有未使用的缓冲区按最近使用时间的顺序链接在双向链表中。

另外，我们还可以使用虚拟盘，利用内存仿真磁盘，称为虚拟盘，RAM盘，由于内存是不稳定存储设备，因此只能存放临时文件，使用我们需要在后台运行一个sync的服务，周期性的向磁盘内写入数据。虚拟盘与磁盘高速缓存的主要区别在于∶虚拟盘中的内容完全由用户控制，而磁盘高速缓存中的内容则是由OS控制的。这种思想同样能够减轻内核负担，让用户空间更好地接管功能。

至此，我们针对文件系统的设计与优化告一段落，且对于该面向万物互联的终端操作系统设计也已全部完成。

# 6. 总结与展望
## 6.1 总结
本论文阐述了针对万物互联时代背景下新型的操作系统设计与实现：以MINIX微内核为基础构建框架，内核只保留非常必要的部分，其它作为各种服务运行在用户空间，以契合新时代终端的功能隔离、扩展性高、可移植、安全可靠等特点，同时灵活支持不同终端类型的功能扩展和不同类型的硬件管理，有利于功能的独立增删与多终端的互通有无。

另外，为了贴近嵌入式系统发展并适应市场流行的宏内核终端，我们参考UNIX、Linux和xv6等的设计理念，基于MINIX微内核基础代码之上，新增了同宏内核一致的系统调用设计，修改简化了我们的进程控制块，并且基于对应功能设计和优化了类UNIX文件系统。

并且，基于全球疫情的背景之下，我们进一步地细化了该操作系统，以适配实现全自动核酸采样的功能，做到对新加入设备的功能扩展、对等待区人员的处理、对各进程运行的分配，同时论文中还阐述了此终端设备系统的处理能力，这些都是面对疫情形势下我们可以做些什么的新思考。
## 6.2 发展前景
本操作系统无疑是可以适应基于微内核的嵌入式操作系统，而[ [12] 马晓娟，嵌入式操作系统的应用及其发展前景[J]，电子制作，2014，2014(10):101-102.DOI:10.16589/j.cnki.cn11-3571/tn.2014.10.122]嵌入式技术已成为当今时代最受欢迎、最具发展前景的IT应用领域。为适应微处理器的复杂性和嵌入式系统的网络连接化发展，操作系统相应的必须易于使用、具有良好的安全性能、能快速上市。因此，内核不仅要具有高实时性和微型化的特点，还需要适应高可靠性和构件组件化的发展趋势，并且开发环境也将变得更加自动化、集成化和人性化。

宏内核可以整合更多功能，微内核可以实现功能拆分和模块化，随着万物互联时代的到来，若希望跨不同的硬件构建统一的平台生态系统，那么组装一个更灵活、更轻量级的微内核无疑是更好的选择。本操作系统核心是微内核架构，系统内的设备驱动程序、进程管理器等系统服务都作为独立的守护进程运行在操作系统内核之外，基于这种灵活的结构，厂商可以方便快速地增删某些服务或是扩展新功能，且无需改变系统核心，这种情况我们可以称之为自动升级。因此，在这种自动升级的能力之下，这种以嵌入式操作系统为核心的终端设备无疑可能发展成为移动互联网、智能家电、交通控制等各个领域具有广阔前景的新技术。但同时我们也要正视本操作系统尚存的不足，比如微内核模块化会导致一个简单的调用所经历的步骤过多，从而导致速度变慢。但未来的处理器速度会更快、性能更好，微内核这种缺陷将在科技的发展下慢慢被淡化。

参考文献
 [1] 《股市动态分析》研究部，华为鸿蒙系统:引领万物互联突破科技封锁[J]，股市动态分析，pp. 2021(12):6-11.
 [2] Andrew S. Tanenbaum, Albert S.Woodhull, 操作系统设计与实现(中文版)，2007, pp. 121
 [3] 吴帆，基于微内核的设备驱动框架研究[D]，浙江大学，2010.
 [4] 岳婧媛,李华,郭亚杰,贺楠,庞滨，基于属性的Minix3系统调用的建模和测试[J]，内蒙古大学学报(自然科学版)，2011，pp. 42(05):570-575.
 [5] Andrew S. Tanenbaum, Albert S.Woodhull, 操作系统设计与实现(中文版)，2007, pp. 32
 [6] 李晓宇，操作系统中并发进程的生产者—消费者问题的研究[J]，许昌学院学报，2013，pp. 32(02):52-56.
 [7] Andrew S. Tanenbaum, Albert S.Woodhull, 操作系统设计与实现(中文版)，2007, pp. 124-126
 [8] Andrew S. Tanenbaum, Albert S.Woodhull, 操作系统设计与实现(中文版)，2007, pp. 274、277
 [9] Andrew S. Tanenbaum, Albert S.Woodhull, 操作系统设计与实现(中文版)，2007, pp. 278-279
 [10] Andrew S. Tanenbaum, Albert S.Woodhull, 操作系统设计与实现(中文版)，2007, pp. 343
 [11] Andrew S. Tanenbaum, Albert S.Woodhull, 操作系统设计与实现(中文版)，2007, pp. 386
 [12] 马晓娟，嵌入式操作系统的应用及其发展前景[J]，电子制作，2014，2014(10):101-102.DOI:10.16589/j.cnki.cn11-3571/tn.2014.10.122
